Я вообще слабо понимаю, зачем это нужно, но ладно.

Единственный способ в этом хоть немного разобраться - переписать код и попробовать прогнать через дебагер. Я буду пользоваться консольным gdb, потому что на экзе другого не будет.

Как с ним работать? Сначала компилируте код с флагом `-g`

```sh
gcc main.c -g -o main
```

потом запускаете его через gdb
```sh
gdb main
```

ставить брейкпоинты `b <номер строки>`, запуск `run`, следующая команда `n`, следующая команда с входом `s`.

## Рубрика ЭКСПЕРИМЕНТЫ

1. Первое, что интересно, объявлненные static сразу инициализируются, им без разницы на то, в каком if они сидят. поэтому E = 5, хоть A = 0, тк объявлена как global

2. дошел до if. дебагер показывает E = 5, но идёт по ветке false???????? Что за бред???? 

3. добавил принт перед if
```C
    ...
    printf("E in function: %d\n", E);
    if (E) {
    ...
```
Показал E = 0. Смеримся. Будем считать, что он никогда не зайдёт в true ветку. Что делает этот static?? У меня ощющение, что он, что-то должен сделать только когда мы до него дойдём. Возможно...

4. ТАК. давайте начнём с A. вылетает ответ из bless. получается для него ответ `A:file:static:0`

5. Попробуем B. стек вызовов main->cursed->bless поэтому B ещё существует. `B:block:automatic:-2`

6. C. Тут будет что-то странное. Дало -3. Значит `C:block:automatic:-3`

7. D. Она вроде как статик. `D:block:static:-4`

8. E. Она та же, что и в вызове. `E:block:automatic:0`