# Задача FirTree: Ёлочка (70 баллов)

Первое января уже давно прошло, но только сейчас вы поняли, что у вас нет ёлки, А какой же новый год без ёлки? Вы твёрдо намерены пойти в лес и найти там подходящую.

Елкой называется дерево (неориентированный ациклический связный граф), все вершины которого имеют степень строго меньше 5, в котором существует путь, выходящий из единственной вершины графа степени 3 и затем проходящий по всем вершинам графа степени 4 и только по ним (если есть). Иными словами, ёлки выглядят как показано на рисунке, отличаясь высотой ствола и длиной веток.

```
         *
        /|\
       * * *
        /|\ \
       * * * *
      / /|\
     * * * *
```

Вы вышли на улицу и врезались в дерево. Так как на улице ночь, вы не можете понять, ёлка это или нет. Поэтому вы решаете ощупать вершины дерева чтобы убедиться, является ли оно ёлкой.

Вершины дерева описываются структурой

```C
struct node {
    int deg;
    struct node **next;
};
```

которая для каждой вершины хранит ее степень `deg` и массив `next` из `deg` указателей на смежные вершины. Порядок, в котором лежат смежные вершины может быть произвольным. Обратите внимание, что так как граф неориентированный, то обе смежные вершины содержат указатели друг на друга.

Напишите функцию `int isFir(struct node* node)`, принимающую на вход произвольную вершину произвольного непустого дерева, и возвращающую 1, если это дерево является ёлкой, и 0 если нет

## Оформление решения
В этой задаче от вас требуется написать только одну функцию, а не всю программу. Файл-посылка должен содержать объявление структуры из условия, искомую функцию, подключение необходимых заголовочных файлов, и любое число вспомогательных функций (они вам понадобятся). Выводить на экран ничего не нужно, проверяться будет возвращаемое значение функции.

## Примеры

### Test 1 (just `deg = 3`)

#### Ввод
```C
struct node f[] = {{1, NULL}, {1, NULL}, {1, NULL}};
struct node* fi[] = {f, f + 1, f + 2};
struct node root = {3, fi};

struct node* rooti = &root;
fi[0]->next = &rooti;
fi[1]->next = &rooti;
fi[2]->next = &rooti;

isFir(&root);
// isFir(f + 1); // to check from leaf
```

#### Вывод
```
1
```

#### Пояснение
```
         *
        /|\
       * * *
```

### Test 2 (no `deg=3`)
#### Ввод
```C
struct node f[] = {{1, NULL}, {1, NULL}, {1, NULL}, {1, NULL}};
struct node* fi[] = {f, f + 1, f + 2, f + 3};
struct node root = {4, fi};

struct node* rooti = &root;
fi[0]->next = &rooti;
fi[1]->next = &rooti;
fi[2]->next = &rooti;
fi[3]->next = &rooti;
```
#### Вывод
```
0
```

#### Пояснение 
```
          *
        /| |\
       * * * *
```